---
title: "Analisis Logilistico"
author: "Oriol"
date: "2024-04-15"
output: html_document
---

```{r}
library(dplyr) ## Para los select
#library("git")
set.seed(Sys.time())
library(ggplot2) #Para plotear
library(pROC)
```

## Carga de los datos 

Cargamos los datos que ya estan filtrados por el script de Python

```{r}
data <- read.csv("sinrepetidos.txt", header = T, sep = "\t")

#colnames(data)
```

## Analisis estadistico 

Vamos a estudiar el dataset para hacernos una idea de lo tenemos y ver que variables son las que potencialmente nos pueden ofrecer información al respecto del mismo.

```{r}
ggplot(data) +
  aes(x = Sexo.del.Paciente, y = Edad.del.Paciente) +
  geom_boxplot(fill = "#0c4c8a") +
  theme_minimal()
```

```{r}
shapiro.test(subset(data, Sexo.del.Paciente == "F")$Edad.del.Paciente)
shapiro.test(subset(data, Sexo.del.Paciente == "M")$Edad.del.Paciente)
```

```{r}
#shapiro.test(subset(data, Penicilina...Sensibilidad == "Sensible")$Edad.del.Paciente)

#subset(data,Penicilina...Sensibilidad)$Edad.del.Paciente
```

### Factorizamos las sensibilidad

En este ejemplo lo realizamos para la Penicilina, más tarde se generaliza al resto de medicamentos.


```{r}
factores<- factor(data$Penicilina...Sensibilidad, exclude = NaN)
factores
```

Una vez obtenido los factores (Sensible - Resistente), ahora asignamos a cada uno un valor (0 o 1). Tambien vamos a asignar un peso a cada paciente acorde a los datos de la media española para hombres y mujeres.

```{r}
factor(data$Penicilina...Sensibilidad, exclude = NaN)
Penicilina <-  data$Penicilina...Sensibilidad
data$Penicilina...Sensibilidad <- unclass(factor(data$Penicilina...Sensibilidad, exclude = NaN))

length(data$Sexo.del.Paciente[data$Sexo.del.Paciente == "F"])

data$Peso[data$Sexo.del.Paciente == "F"] <- rnorm(69, 63, 10)
data$Peso[data$Sexo.del.Paciente == "M"] <- rnorm(160, 75.8, 10)

data$Penicilina...Sensibilidad[data$Penicilina...Sensibilidad == 1] = NaN
```


```{r}
#test <- wilcox.test(data$Penicilina...Sensibilidad ~ data$Sexo.del.Paciente, alternative = "two.sided")
#test
```


# Tener en cuenta que entre variables categoricas hay que hacer un tipo de test (wilcox). Entre variable continua y categorica otro (kruskal) y entre continuas otro (Xi cuadrado o t-test)

Hagamos un estudio de las correlaciones para ver si existen algun sesgo de las variables.

```{r}
dataparacorr <- data.frame(data$Penicilina...Sensibilidad, data$Sexo.del.Paciente, data$Edad.del.Paciente, data$Peso 
                           )
colnames(dataparacorr) <- c("Penicilina...Sensibilidad", "Sexo.del.Paciente","Edad.del.Paciente", "Peso")
dataparacorr <- na.omit(dataparacorr)

CHIS <- lapply(dataparacorr[,-1], function(x) chisq.test(dataparacorr[,1], x ))
do.call(rbind, CHIS)[,c(1,3)]
```

En principio, las correlaciones están por encima del valor del p-value = 0.05. Por tanto, se puede asumir con relativa seguridad que las variables son independientes en su origen. 

```{r}
dataparacorr$Sexo.del.Paciente[dataparacorr$Sexo.del.Paciente == "M"] = 0
dataparacorr$Sexo.del.Paciente[dataparacorr$Sexo.del.Paciente == "F"] = 1

dataparacorr[,2] <- as.numeric(dataparacorr[,2])

WIL <- wilcox.test(dataparacorr$Penicilina...Sensibilidad, dataparacorr$Sexo.del.Paciente)
WIL
KRUS <- lapply(dataparacorr[,2:4],  function(x) kruskal.test( dataparacorr$Penicilina...Sensibilidad, x) )
do.call(rbind, KRUS)[,c(1,3)]
```


# GLM por Antibiotico.

```{r}
results <- glm(Penicilina...Sensibilidad ~ Edad.del.Paciente+Sexo.del.Paciente+Peso , data, na.action = na.omit, family =quasi())
summary(results)
```

```{r}
dataAuxiliar <- data.frame(data$Penicilina...Sensibilidad, data$Sexo.del.Paciente, data$Edad.del.Paciente, data$Peso)
dataAuxiliar <- na.omit(dataAuxiliar)

results <- glm(data.Penicilina...Sensibilidad ~ data.Edad.del.Paciente+data.Sexo.del.Paciente+data.Peso , dataAuxiliar, family =quasi())

#results$fitted.values
threshold_2 <- 2.5

predictions <- dataAuxiliar %>% 
  mutate(pred.fit = results$fitted.values,
    predicted_class = if_else(pred.fit > threshold_2, 3, 2),
    correct = if_else( predicted_class == data.Penicilina...Sensibilidad, 'correct', 'incorrect')
  )

# Step 4: Construct the confusion matrix
confusion_matrix <- table(predictions$data.Penicilina...Sensibilidad, predictions$predicted_class)
tn <- confusion_matrix["2", "2"]  # True Negatives
tp <- confusion_matrix["3", "3"]  # True Positives
fn <- confusion_matrix["3", "2"]  # False Negatives
fp <- confusion_matrix["2", "3"]  # False Positives

# Calculate accuracy
accuracy <- (tp + tn) / (tp + tn + fp + fn)

# Calculate precision
precision <- tp / (tp + fp)

# Calculate recall
recall <- tp / (tp + fn)
cat("Metrics:\n")
cat("Accuracy: ", accuracy, "\t", "Precision: ", precision, "\t", "Recall: ", recall, "\n")

# Create a named list for better clarity
confusion_matrix_named <- matrix(c(tn, fp, fn, tp),
                                 nrow = 2,
                                 dimnames = list('Actual' = c('Resistente', 'Sensible'),
                                                 'Predicted' = c('Resistente', 'Sensible')))

# Print the confusion matrix with names
cat("Confusion Matrix (named):\n")
print(confusion_matrix_named)
```

```{r}
roc_curve <- roc(predictions$data.Penicilina...Sensibilidad, predictions$pred.fit, levels = c(2, 3), direction = "<")
auroc <- auc(roc_curve)

# Print the AUROC
cat("AUROC: ", auroc, "\n")

# Optionally, plot the ROC curve
plot(roc_curve, main = "ROC Curve", col = "blue", lwd = 2)
abline(a = 0, b = 1, lty = 2, col = "red")  # Diagonal line for reference
```

```{r}
new_obs <- data.frame(data.Edad.del.Paciente = c(42,65), data.Sexo.del.Paciente = c("M","F"), data-Peso = c(65, 53) )


predict(
  results, 
  newdata = new_obs,
  type = 'response'
)
```



```{r}
#install.packages("gtsummary")
library(gtsummary)

results %>% 
  tbl_regression(intercept=TRUE, conf.level=0.9) %>%
  add_glance_source_note() %>%
  add_global_p() %>%
  add_q() 
#predict(modelo_results,dataset.test)
```



```{r}
par(mfrow = c(2,2))
plot(results)
```

# Generalizacion a todas las descripciones

```{r}
descripciones <- unique(data$Descripción)
data$Penicilina...Sensibilidad <- Penicilina

medicamentos <- colnames( select(data, contains("Sensibilidad")))
```

```{r,  warning= TRUE}
#### Warnings por coercion, por tratar variables logicas a numericas ####

##data$Penicilina...Sensibilidad <- unclass(factor(data$Penicilina...Sensibilidad, exclude = NaN))

for (j in medicamentos) {  ##Cada vez que encuentra una celda vacia problemas
  if( sum(is.na(data[[j]])) == length(data[[j]]) ){ #Si es nula la obviamos del analisis
           next;
  }else{
    data[[j]] <- unclass( factor(data[[j]], levels = c("Sensible","Sensible EI","Resistente") , exclude = c(NaN,NA,"") ))
  }
}
```

```{r} 
### Metodo unclass pero no podemos ignorar los NANs

#for (i in medicamentos){ ##Factorizamos y asignamos valor a la variable categorica    unclass(data$i)
#    data[[i]] <- unclass( factor(data[[i]] , exclude = NaN))
#    data[[i]][ data[[i]] == 1 ] = NaN
#}
```

### Generalizacion a todas las descripciones y medicamentos

```{r}
results_frame <- list()  #Actualizar para poder guardar con cada descripcion un lista de dataframes de medicamentos
for(i in descripciones){
  if ( sum(data$Descripción == i) < 20 ){ #Filtramos para ver si hay cantidad suficiente de datos para hacer estadistica
    next;
  }else{
    results_frame[[i]] <- list()
    data_Aux = data[ data$Descripción == i,] #Lista auxiliar en funcion del organismo
    for(j in medicamentos){ #Columnas correspondientes sensibilidad de cada medicamentos
        dim <- length(data_Aux[[j]]) 
        numnas <-  sum(is.na(data_Aux[[j]]))
        res <- dim - numnas 
        if(res <= 3  ){ #Si es nula la obviamos del analisis y si solo hay un caso tambien pasamos
           next;
         }else {
            #print(j)
            results <- glm(formula = paste0(j ," ~ Edad.del.Paciente*Sexo.del.Paciente+Peso"), data_Aux, 
                           na.action = na.omit ,family = quasi() ) #Modelo 
            results_frame[[i]][[j]]<- coef(summary(results)) #Guardamos los resultados en una lista de listas
         }
      }
  }
}
```


```{r}
results_frame
```



```{r, echo = T, results = 'hide'}
#for (i in descripciones) {
#  print(c(i, nrow(data[ data$Descripción == i, ] ) ))
#}
```


```{r}
data_Staph = data[ data$Descripción == "Staphylococcus epidermidis",]

results <- glm(Penicilina...Sensibilidad ~ Edad.del.Paciente+Sexo.del.Paciente+Peso, data_Staph, na.action = na.omit,family =quasi())
summary(results)

```

```{r}
par(mfrow = c(2,2))
plot(results)
```

```{r}
data_haem = data[ data$Descripción == "Staphylococcus haemolyticus",]

results <- glm(Penicilina...Sensibilidad ~ Edad.del.Paciente+Sexo.del.Paciente+Peso, data_haem, na.action = na.omit,family =quasi())
#summary(results)
```

# Arbol de decisiones

Primero incluimos la libreria:

```{r}
library(rpart)
```


Probamos con el organismo para el cual hay más pacientes. Y un tipo de medicamento con una distribución en la cual apaarecen las tres posibilidades de sensibilidad. 

```{r}
data_epi = data[ data$Descripción == "Staphylococcus epidermidis",]

tree_model <- rpart(Linezolid...Sensibilidad ~ Edad.del.Paciente + Sexo.del.Paciente + Peso, data = data_epi, na.action = na.omit)

summary(tree_model)
```

Ahora, podemos modificar el bucle para calcular los modelos logisticos y asi generalizar para los arboles de decisión, cambiando los nombres de las variables para guardar los resultados. 

```{r}
results_trees <- list()  #Actualizar para poder guardar con cada descripcion un lista de dataframes de medicamentos
for(i in descripciones){
  if ( sum(data$Descripción == i) < 20 ){ #Filtramos para ver si hay cantidad suficiente de datos para hacer estadistica
    next;
  }else{
    results_frame[[i]] <- list()
    data_Aux = data[ data$Descripción == i,] #Lista auxiliar en funcion del organismo
    for(j in medicamentos){ #Columnas correspondientes sensibilidad de cada medicamentos
        dim <- length(data_Aux[[j]]) 
        numnas <-  sum(is.na(data_Aux[[j]]))
        res <- dim - numnas 
        if(res <= 3  ){ #Si es nula la obviamos del analisis y si solo hay un caso tambien pasamos
           next;
         }else {
            #print(j)
            tree_model <- rpart(paste0(j ," ~ Edad.del.Paciente*Sexo.del.Paciente+Peso"), data = data_Aux, na.action = na.omit)
            results_trees[[i]][[j]]<- tree_model #Guardamos los resultados en una lista de listas
         }
      }
  }
}
```



```{r}
# Plot the tree
plot(tree_model)
text(tree_model, use.n = TRUE)
```

### Redes neuronales 

Vamos ahora a proponer redes neuronales para resolver el problema. Usaremos la libreria h2o que implementa redes neuronales. 

```{r}
library(h2o)

h2o.init()
```


```{r}
modelo_dl_200_200 <- h2o.deeplearning(
                      x = c("Edad.del.Paciente", "Sexo.del.Paciente", "Peso"),
                      y = "Linezolid...Sensibilidad",
                      distribution = "multinomial",
                      training_frame = datos_espiral_h2o,
                      standardize = TRUE,
                      activation = "Rectifier",
                      hidden = c(200, 200),
                      stopping_rounds = 0,
                      epochs = 1000,
                      seed = 123,
                      model_id = "modelo_dl_200_200"
                    )
```



Guardo el antibiograma limpio.
```{r}
#data <- subset(data, select = -c(Servicio))
write.table(data, file = "Antibiogramaclean.csv" , sep = "\t")
```




